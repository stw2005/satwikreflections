<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Design and Problem Solving</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <h1>Algorithm Design and Problem Solving</h1>
    </header>
    
    <main>
        <section class="content">
            <h2>1. Problem Solving Inspired by Nature</h2>
            <p>Nature has inspired numerous algorithmic strategies:</p>
            <ul>
                <li><strong>Recursion:</strong> Solves problems by dividing them into smaller, more manageable subproblems, such as calculating Fibonacci numbers or navigating mazes.</li>
                <li><strong>Iteration:</strong> Uses loops to repeat tasks, like calculating factorials or iterating through arrays.</li>
                <li><strong>Backtracking:</strong> Explores all possible solutions, discarding those that are invalid. Examples include solving the N-Queens problem or the Towers of Hanoi puzzle.</li>
            </ul>
        </section>

        <section class="content">
            <h2>2. Assessing Algorithm Efficiency</h2>
            <p>Evaluating efficiency is crucial when developing algorithms, especially for large-scale systems:</p>
            <ul>
                <li><strong>Time Complexity:</strong> Measures how quickly an algorithm performs its task.</li>
                <li><strong>Space Complexity:</strong> Evaluates how much memory the algorithm uses during execution.</li>
            </ul>
        </section>

        <section class="content">
            <h2>3. Fundamental Principles of Algorithm Design</h2>
            <p>Efficient algorithm design relies on well-established strategies:</p>
            <ul>
                <li><strong>Divide and Conquer:</strong> Breaks problems into smaller, more manageable parts to be solved independently, such as in Merge Sort.</li>
                <li><strong>Dynamic Programming:</strong> Stores intermediate results to avoid redundant calculations.</li>
                <li><strong>Backtracking:</strong> Explores all potential solutions while dynamically eliminating invalid ones.</li>
            </ul>
        </section>

        <section class="content">
            <h2>4. Trees and Hierarchical Data Structures</h2>
            <p>Trees are versatile structures for representing hierarchical relationships:</p>
            <ul>
                <li><strong>Binary Search Tree (BST):</strong> Enables efficient operations like searching and sorting.</li>
                <li><strong>AVL Tree:</strong> A balanced BST that ensures logarithmic height for fast operations.</li>
                <li><strong>Red-Black Tree:</strong> A self-balancing BST that helps maintain efficient performance.</li>
                <li><strong>Trie:</strong> Optimized for managing strings, often used in functionalities like autocomplete.</li>
            </ul>
        </section>

        <section class="content">
            <h2>5. Optimized Query Algorithms for Arrays</h2>
            <p>Specialized data structures improve array-based computations:</p>
            <ul>
                <li><strong>Sparse Table:</strong> Supports constant-time range queries after preprocessing in <span class="math">O(n log n)</span>.</li>
                <li><strong>Segment Tree:</strong> Handles complex queries, such as sums or maximums over subarrays.</li>
                <li><strong>Fenwick Tree (Binary Indexed Tree):</strong> Useful for cumulative frequency and prefix sum operations.</li>
                <li><strong>Look-Up Table:</strong> Precomputes values to allow rapid access during repeated queries.</li>
            </ul>
        </section>

        <section class="content">
            <h2>6. Comparing Trees and Graphs</h2>
            <p>Both trees and graphs represent relationships, though they serve different purposes:</p>
            <ul>
                <li><strong>Trees:</strong> A specialized type of graph without cycles, commonly used for applications like file systems and decision-making models.</li>
                <li><strong>Graphs:</strong> More flexible structures that may contain cycles, suitable for problems like network routing and managing relational data.</li>
            </ul>
            <p>Traversal techniques include:</p>
            <ul>
                <li><strong>Depth-First Search (DFS):</strong> Explores as deeply as possible into a branch before backtracking.</li>
                <li><strong>Breadth-First Search (BFS):</strong> Explores nodes level by level, ideal for finding the shortest path in unweighted graphs.</li>
            </ul>
        </section>

        <section class="content">
            <h2>7. Sorting and Searching Algorithms</h2>
            <p>Sorting and searching are fundamental operations in algorithm design:</p>
            <ul>
                <li><strong>Sorting:</strong> Includes algorithms like Bubble Sort, Merge Sort, Quick Sort, Selection Sort, Insertion Sort, and Heap Sort.</li>
                <li><strong>Searching:</strong> Techniques include Linear Search, Binary Search, DFS, and BFS.</li>
            </ul>
        </section>

        <section class="content">
            <h2>8. The Significance of Graph Algorithms</h2>
            <p>Graphs are crucial for solving connectivity and optimization problems:</p>
            <ul>
                <li><strong>Traversal Algorithms:</strong> DFS and BFS systematically explore graph nodes.</li>
                <li><strong>Shortest Path Algorithms:</strong> Dijkstra, Bellman-Ford, and Floyd-Warshall find optimal paths in weighted graphs.</li>
                <li><strong>Spanning Tree Algorithms:</strong> Kruskal’s and Prim’s algorithms create minimum spanning trees that connect all nodes with the least cost.</li>
            </ul>
        </section>
    </main>
</body>
</html>
